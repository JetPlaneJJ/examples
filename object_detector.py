b'--- object_detector.py\t(original)'
b'+++ object_detector.py\t(refactored)'
b'@@ -11,8 +11,10 @@'
b' # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.'
b' # See the License for the specific language governing permissions and'
b' # limitations under the License.'
b'-"""A module to run object detection with a TensorFlow Lite model."""'
b'-'
b'+u"""A module to run object detection with a TensorFlow Lite model."""'
b'+'
b'+from __future__ import division'
b'+from __future__ import absolute_import'
b' import json'
b' import platform'
b' from typing import List, NamedTuple'
b'@@ -20,6 +22,7 @@'
b' import cv2'
b' import numpy as np'
b' from tflite_support import metadata'
b'+from itertools import ifilter'
b' '
b' # pylint: disable=g-import-not-at-top'
b' try:'
b'@@ -37,29 +40,29 @@'
b' '
b' '
b' class ObjectDetectorOptions(NamedTuple):'
b'-  """A config to initialize an object detector."""'
b'+  u"""A config to initialize an object detector."""'
b' '
b'   enable_edgetpu: bool = False'
b'-  """Enable the model to run on EdgeTPU."""'
b'-'
b'-  label_allow_list: List[str] = None'
b'-  """The optional allow list of labels."""'
b'-'
b'-  label_deny_list: List[str] = None'
b'-  """The optional deny list of labels."""'
b'+  u"""Enable the model to run on EdgeTPU."""'
b'+'
b'+  label_allow_list: List[unicode] = None'
b'+  u"""The optional allow list of labels."""'
b'+'
b'+  label_deny_list: List[unicode] = None'
b'+  u"""The optional deny list of labels."""'
b' '
b'   max_results: int = -1'
b'-  """The maximum number of top-scored detection results to return."""'
b'+  u"""The maximum number of top-scored detection results to return."""'
b' '
b'   num_threads: int = 1'
b'-  """The number of CPU threads to be used."""'
b'+  u"""The number of CPU threads to be used."""'
b' '
b'   score_threshold: float = 0.0'
b'-  """The score threshold of detection results to return."""'
b'+  u"""The score threshold of detection results to return."""'
b' '
b' '
b' class Rect(NamedTuple):'
b'-  """A rectangle in 2D space."""'
b'+  u"""A rectangle in 2D space."""'
b'   left: float'
b'   top: float'
b'   right: float'
b'@@ -67,41 +70,41 @@'
b' '
b' '
b' class Category(NamedTuple):'
b'-  """A result of a classification task."""'
b'-  label: str'
b'+  u"""A result of a classification task."""'
b'+  label: unicode'
b'   score: float'
b'   index: int'
b' '
b' '
b' class Detection(NamedTuple):'
b'-  """A detected object as the result of an ObjectDetector."""'
b'+  u"""A detected object as the result of an ObjectDetector."""'
b'   bounding_box: Rect'
b'   categories: List[Category]'
b' '
b' '
b' def edgetpu_lib_name():'
b'-  """Returns the library name of EdgeTPU in the current platform."""'
b'+  u"""Returns the library name of EdgeTPU in the current platform."""'
b'   return {'
b"-      'Darwin': 'libedgetpu.1.dylib',"
b"-      'Linux': 'libedgetpu.so.1',"
b"-      'Windows': 'edgetpu.dll',"
b"+      u'Darwin': u'libedgetpu.1.dylib',"
b"+      u'Linux': u'libedgetpu.so.1',"
b"+      u'Windows': u'edgetpu.dll',"
b'   }.get(platform.system(), None)'
b' '
b' '
b'-class ObjectDetector:'
b'-  """A wrapper class for a TFLite object detection model."""'
b'-'
b"-  _OUTPUT_LOCATION_NAME = 'location'"
b"-  _OUTPUT_CATEGORY_NAME = 'category'"
b"-  _OUTPUT_SCORE_NAME = 'score'"
b"-  _OUTPUT_NUMBER_NAME = 'number of detections'"
b'+class ObjectDetector(object):'
b'+  u"""A wrapper class for a TFLite object detection model."""'
b'+'
b"+  _OUTPUT_LOCATION_NAME = u'location'"
b"+  _OUTPUT_CATEGORY_NAME = u'category'"
b"+  _OUTPUT_SCORE_NAME = u'score'"
b"+  _OUTPUT_NUMBER_NAME = u'number of detections'"
b' '
b'   def __init__('
b'       self,'
b'-      model_path: str,'
b'-      options: ObjectDetectorOptions = ObjectDetectorOptions()'
b'-  ) -> None:'
b'-    """Initialize a TFLite object detection model.'
b'+      model_path,'
b'+      options = ObjectDetectorOptions()'
b'+  ):'
b'+    u"""Initialize a TFLite object detection model.'
b' '
b'     Args:'
b'         model_path: Path to the TFLite model.'
b'@@ -117,27 +120,27 @@'
b' '
b'     # Save model metadata for preprocessing later.'
b'     model_metadata = json.loads(displayer.get_metadata_json())'
b"-    process_units = model_metadata['subgraph_metadata'][0]["
b"-        'input_tensor_metadata'][0]['process_units']"
b"+    process_units = model_metadata[u'subgraph_metadata'][0]["
b"+        u'input_tensor_metadata'][0][u'process_units']"
b'     mean = 127.5'
b'     std = 127.5'
b'     for option in process_units:'
b"-      if option['options_type'] == 'NormalizationOptions':"
b"-        mean = option['options']['mean'][0]"
b"-        std = option['options']['std'][0]"
b"+      if option[u'options_type'] == u'NormalizationOptions':"
b"+        mean = option[u'options'][u'mean'][0]"
b"+        std = option[u'options'][u'std'][0]"
b'     self._mean = mean'
b'     self._std = std'
b' '
b'     # Load label list from metadata.'
b'     file_name = displayer.get_packed_associated_file_list()[0]'
b'     label_map_file = displayer.get_associated_file_buffer(file_name).decode()'
b'-    label_list = list(filter(len, label_map_file.splitlines()))'
b'+    label_list = list(ifilter(len, label_map_file.splitlines()))'
b'     self._label_list = label_list'
b' '
b'     # Initialize TFLite model.'
b'     if options.enable_edgetpu:'
b'       if edgetpu_lib_name() is None:'
b'-        raise OSError("The current OS isn\'t supported by Coral EdgeTPU.")'
b'+        raise OSError(u"The current OS isn\'t supported by Coral EdgeTPU.")'
b'       interpreter = Interpreter('
b'           model_path=model_path,'
b'           experimental_delegates=[load_delegate(edgetpu_lib_name())],'
b'@@ -161,7 +164,7 @@'
b"     # because of the op's ports of TFLITE_DETECTION_POST_PROCESS"
b'     # (https://github.com/tensorflow/tensorflow/blob/a4fe268ea084e7d323133ed7b986e0ae259a2bc7/tensorflow/lite/kernels/detection_postprocess.cc#L47-L50).'
b'     sorted_output_indices = sorted('
b"-        [output['index'] for output in interpreter.get_output_details()])"
b"+        [output[u'index'] for output in interpreter.get_output_details()])"
b'     self._output_indices = {'
b'         self._OUTPUT_LOCATION_NAME: sorted_output_indices[0],'
b'         self._OUTPUT_CATEGORY_NAME: sorted_output_indices[1],'
b'@@ -169,13 +172,13 @@'
b'         self._OUTPUT_NUMBER_NAME: sorted_output_indices[3],'
b'     }'
b' '
b"-    self._input_size = input_detail['shape'][2], input_detail['shape'][1]"
b"-    self._is_quantized_input = input_detail['dtype'] == np.uint8"
b"+    self._input_size = input_detail[u'shape'][2], input_detail[u'shape'][1]"
b"+    self._is_quantized_input = input_detail[u'dtype'] == np.uint8"
b'     self._interpreter = interpreter'
b'     self._options = options'
b' '
b'-  def detect(self, input_image: np.ndarray) -> List[Detection]:'
b'-    """Run detection on an input image.'
b'+  def detect(self, input_image):'
b'+    u"""Run detection on an input image.'
b' '
b'     Args:'
b'         input_image: A [height, width, 3] RGB image. Note that height and width'
b'@@ -201,8 +204,8 @@'
b'     return self._postprocess(boxes, classes, scores, count, image_width,'
b'                              image_height)'
b' '
b'-  def _preprocess(self, input_image: np.ndarray) -> np.ndarray:'
b'-    """Preprocess the input image as required by the TFLite model."""'
b'+  def _preprocess(self, input_image):'
b'+    u"""Preprocess the input image as required by the TFLite model."""'
b' '
b'     # Resize the input'
b'     input_tensor = cv2.resize(input_image, self._input_size)'
b'@@ -217,21 +220,21 @@'
b'     return input_tensor'
b' '
b'   def _set_input_tensor(self, image):'
b'-    """Sets the input tensor."""'
b"-    tensor_index = self._interpreter.get_input_details()[0]['index']"
b'+    u"""Sets the input tensor."""'
b"+    tensor_index = self._interpreter.get_input_details()[0][u'index']"
b'     input_tensor = self._interpreter.tensor(tensor_index)()[0]'
b'     input_tensor[:, :] = image'
b' '
b'   def _get_output_tensor(self, name):'
b'-    """Returns the output tensor at the given index."""'
b'+    u"""Returns the output tensor at the given index."""'
b'     output_index = self._output_indices[name]'
b'     tensor = np.squeeze(self._interpreter.get_tensor(output_index))'
b'     return tensor'
b' '
b'-  def _postprocess(self, boxes: np.ndarray, classes: np.ndarray,'
b'-                   scores: np.ndarray, count: int, image_width: int,'
b'-                   image_height: int) -> List[Detection]:'
b'-    """Post-process the output of TFLite model into a list of Detection objects.'
b'+  def _postprocess(self, boxes, classes,'
b'+                   scores, count, image_width,'
b'+                   image_height):'
b'+    u"""Post-process the output of TFLite model into a list of Detection objects.'
b' '
b'     Args:'
b'         boxes: Bounding boxes of detected objects from the TFLite model.'
b'@@ -247,7 +250,7 @@'
b'     results = []'
b' '
b'     # Parse the model output into a list of Detection entities.'
b'-    for i in range(count):'
b'+    for i in xrange(count):'
b'       if scores[i] >= self._options.score_threshold:'
b'         y_min, x_min, y_max, x_max = boxes[i]'
b'         bounding_box = Rect('
b'@@ -273,14 +276,14 @@'
b'     filtered_results = sorted_results'
b'     if self._options.label_deny_list is not None:'
b'       filtered_results = list('
b'-          filter('
b'+          ifilter('
b'               lambda detection: detection.categories[0].label not in self.'
b'               _options.label_deny_list, filtered_results))'
b' '
b'     # Keep only detections in allow list'
b'     if self._options.label_allow_list is not None:'
b'       filtered_results = list('
b'-          filter('
b'+          ifilter('
b'               lambda detection: detection.categories[0].label in self._options.'
b'               label_allow_list, filtered_results))'
b' '
